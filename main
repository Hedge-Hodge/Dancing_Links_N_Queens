import numpy as py
import math


# Function which creates an empty matrix of size n^2 by 2(3n-3) to hold all possible placements and constraints
# Args: n = size of board
def create_one_zero_matrix(n):
    null_row = []
    for i in range(2*(3*n-3)):
        null_row.append(0)
    one_zero = py.array([null_row])
    for i in range(n**2 - 1):
        one_zero = py.append(one_zero, [null_row], 0)
    return one_zero


# Function which populates the one-zero matrix according to all possible queen placements
# Args: empty 1-0 matrix created by 'create_one_zero_matrix', n = size of board
def populate_one_zero_matrix(one_zero_matrix, n):
    counter = 0
    # Iterate over the row indices, from (0,j) to (n,j)
    for i in range(n):
        # Set current x value
        x = i
        # Iterate over the column indices, from (i,0) to (i,n)
        for k in range(n):
            print("Iterate, ", counter)
            # Define an emtpy row, with length equal to the number of constraints
            current_row = []
            for p in range(2 * (3 * n - 3)):
                current_row.append(0)
            # Set current y value
            y = k
            # Compute the diagonal and backward diagonal constraints
            diag_constraint = (2*n - 1) + x + y
            back_diag_constraint = 5*n - 4 - 1 - x + y
            # Now populate the current row with 1's wherever constraints are satisfied
            current_row[x] = 1
            current_row[y + n] = 1
            # Check to see if this is a significant diagonal
            if (2 * n - 1) < diag_constraint <= (4*n - 4):
                current_row[diag_constraint] = 1
            # Check to see if this is a significant backward diagonal
            if (4*n - 3) <= back_diag_constraint < (6*n - 6):
                current_row[back_diag_constraint] = 1
            one_zero_matrix[counter] = current_row
            counter = counter + 1
    return one_zero_matrix


class Column:
    def __init__(self):
        self.left = None
        self.right = None
        self.up = None
        self.down = None
        self.size = 0
        self.name = None


class Node:
    def __init__(self):
        self.left = None
        self.right = None
        self.up = None
        self.down = None


class CircularList:
    def __init__(self, master_node=Column()):
        self.master_node = master_node
        master_node.name = "Master"
        master_node.right = None
        master_node.left = master_node

    def find_column_by_name(self, name):
        current_node = self.master_node
        index = 0
        while current_node.name != name:
            current_node = current_node.right
            index = index + 1
        return index

    def find_column_by_index(self, index):
        current_column = self.master_node
        for i in range(index):
            current_column = current_column.right
        return current_column

    def convert_one_zero(self, matrix):
        dims = py.shape(matrix)
        x = dims[0]
        y = dims[1]
        print("x: ", x)
        print("y: ", y)
        n = math.sqrt(x)
        # Create the column headers
        for i in range(y):
            current_node = self.master_node
            while current_node.right is not None:
                current_node = current_node.right
            new = Column()
            if i < n:
                new.name = "Row {0}".format(i + 1)
            elif i < 2*n:
                new.name = "File {0}".format(int((i % n) + 1))
            elif i < (4*n - 3):
                new.name = "Diagonal {0}".format(int((i % (2*n)) + 1))
            else:
                new.name = "Back Diagonal {0}".format(int((i % (4*n - 3)) + 1))
            new.left = current_node
            current_node.right = new
        # Create each row
        for i in range(x):
            # Extract corresponding row from 1-0 Matrix
            current_row = matrix[i]
            first_node = True  # Bad practice, can't think of a better solution right now
            # Iterate over the extracted row
            for j in range(y):
                # If significant
                if current_row[j] == 1:
                    new = Node()  # Create new node
                    current_above = self.find_column_by_index(j+1)  # Find corresponding header for node
                    # Find 'lowest' node in the column
                    while current_above.down is not None:
                        current_above = current_above.down
                    # Connect new node above, old lowest node below
                    current_above.down = new
                    new.up = current_above
                    # If this is the first node, no previous node declared and no left connection available
                    if first_node:
                        prev_node = new  # Record this node for the next iteration
                        first_node = False
                    else:
                        # Connect new node on the left to the previous node in this row
                        new.left = prev_node
                        prev_node.right = new
                        prev_node = new
        # Finally join the edges of the lists
        # Start at the master node
        current_header = self.master_node  # Current header will be used to traverse the chain horizontally
        # Iterate right until we are at the last node
        while current_header.right is not None:
            current_node = current_header  # Current node will be used to traverse the chain vertically
            # Iterate down until we are at the 'lowest' node
            while current_node.down is not None:
                current_node = current_node.down  # Step down
            # Join the 'lowest' node and the header, above and below
            current_node.down = current_header
            current_header.up = current_node
            current_header = current_header.right  # Step right
        # Do one final iteration of the loop, for the furthest right header
        # Bad practice!
        current_node = current_header  # Current node will be used to traverse the chain vertically
        # Iterate down until we are at the 'lowest' node
        while current_node.down is not None:
            current_node = current_node.down  # Step down
        # Join the 'lowest' node and the header, above and below
        current_node.down = current_header
        current_header.up = current_node
        # Join the furthest right header to the master and vice versa
        current_header.right = self.master_node
        self.master_node.left = current_header
        return self.master_node


N = 4
print("N = ", N)
print("Creating empty 1-0 Matrix...")
current_matrix = create_one_zero_matrix(N)
print("Done.")
print(current_matrix)
print("Populating 1-0 Matrix...")
populate_one_zero_matrix(current_matrix, N)
print("Done.")
print(py.shape(current_matrix))
print(current_matrix)

# TESTS
test = CircularList()
test.convert_one_zero(current_matrix)
this_node = test.master_node
while this_node.right != test.master_node:
    this_node = this_node.right
    below = this_node
    print(this_node.name)
    while below.down != this_node:
        below = below.down
        print(below)

